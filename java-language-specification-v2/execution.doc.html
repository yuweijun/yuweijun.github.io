<html>
<head>
<title> Execution</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="exceptions.doc.html">Prev</a> | <a href="binaryComp.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<hr><br>
 
<a name="44410"></a>
<p><strong>
CHAPTER
 12 </strong></p>
<a name="44411"></a>
<h1>Execution</h1>
<hr><p>
<a name="44413"></a>
This chapter specifies activities that occur during execution of a program. It is organized around the life cycle of a Java virtual machine and of the classes, interfaces, and objects that form a program.<p>
<a name="46419"></a>
A Java virtual machine starts up by loading a specified class and then invoking the method <code>main</code> in this specified class. Section <a href="execution.doc.html#44444">&#167;12.1</a> outlines the loading, linking, and initialization steps involved in executing <code>main</code>, as an introduction to the concepts in this chapter. Further sections specify the details of loading <a href="execution.doc.html#44459">(&#167;12.2)</a>, linking <a href="execution.doc.html#44487">(&#167;12.3)</a>, and initialization <a href="execution.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="46572"></a>
The chapter continues with a specification of the procedures for creation of new class instances <a href="execution.doc.html#44670">(&#167;12.5)</a>; and finalization of class instances <a href="execution.doc.html#44748">(&#167;12.6)</a>. It concludes by describing the unloading of classes <a href="execution.doc.html#74294">(&#167;12.7)</a> and the procedure followed when a program exits <a href="execution.doc.html#44857">(&#167;12.8)</a>. <p>
<a name="44444"></a>
<h2>12.1    Virtual Machine Start-Up</h2>
<a name="60151"></a>
A Java virtual machine starts execution by invoking the method <code>main</code> of some specified class, passing it a single argument, which is an array of strings. In the examples in this specification, this first class is typically called <code>Test</code>.<p>
<a name="58581"></a>
The precise semantics of virtual machine start-up are given in chapter 5 of <em>The Java</em><i></i><em> Virtual Machine Specification, Second Edition</em>. Here we present an overview of the process from the viewpoint of the Java programming language.<p>
<a name="46661"></a>
The manner in which the initial class is specified to the Java virtual machine is beyond the scope of this specification, but it is typical, in host environments that use command lines, for the fully-qualified name of the class to be specified as a command-line argument and for following command-line arguments to be used as strings to be provided as the argument to the method <code>main</code>. For example, in a UNIX implementation, the command line:<p>
<blockquote><pre>java Test reboot Bob Dot Enzo
</pre></blockquote><a name="46663"></a>
will typically start a Java virtual machine by invoking method <code>main</code> of class <code>Test</code> (a class in an unnamed package), passing it an array containing the four strings <code>"reboot"</code>, <code>"Bob"</code>, <code>"Dot"</code>, and <code>"Enzo"</code>.<p>
<a name="46666"></a>
We now outline the steps the virtual machine may take to execute <code>Test</code>, as an example of the loading, linking, and initialization processes that are described further in later sections.<p>
<a name="46619"></a>
<h3>12.1.1    Load the Class Test</h3>
<a name="46533"></a>
The initial attempt to execute the method <code>main</code> of class <code>Test</code> discovers that the class <code>Test</code> is not loaded-that is, that the virtual machine does not currently contain a binary representation for this class. The virtual machine then uses a class loader to attempt to find such a binary representation. If this process fails, then an error is thrown. This loading process is described further in <a href="execution.doc.html#44459">&#167;12.2</a>.<p>
<a name="46620"></a>
<h3>12.1.2    Link Test: Verify, Prepare, (Optionally) Resolve</h3>
<a name="47121"></a>
After <code>Test</code> is loaded, it must be initialized before <code>main</code> can be invoked. And <code>Test</code>, like all (class or interface) types, must be linked before it is initialized. Linking involves verification, preparation and (optionally) resolution. Linking is described further in <a href="execution.doc.html#44487">&#167;12.3</a>.<p>
<a name="47125"></a>
Verification checks that the loaded representation of <code>Test</code> is well-formed, with a proper symbol table. Verification also checks that the code that implements <code>Test</code> obeys the semantic requirements of the Java programming language and the Java virtual machine. If a problem is detected during verification, then an error is thrown. Verification is described further in <a href="execution.doc.html#44491">&#167;12.3.1</a>.<p>
<a name="60158"></a>
Preparation involves allocation of static storage and any data structures that are used internally by the virtual machine, such as method tables. Preparation is described further in <a href="execution.doc.html#47979">&#167;12.3.2</a>.<p>
<a name="46935"></a>
Resolution is the process of checking symbolic references from <code>Test</code> to other classes and interfaces, by loading the other classes and interfaces that are mentioned and checking that the references are correct.<p>
<a name="48724"></a>
The resolution step is optional at the time of initial linkage. An implementation may resolve symbolic references from a class or interface that is being linked very early, even to the point of resolving all symbolic references from the classes and interfaces that are further referenced, recursively. (This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of "static" linkage that has been done for many years in simple implementations of the C language. (In these implementations, a compiled program is typically represented as an "<code>a.out</code>" file that contains &#32;a fully-linked version of the program, including completely resolved links to library routines used by the program. Copies of these library routines are included in the "<code>a.out</code>" file.)<p>
<a name="60164"></a>
An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the "laziest" form of resolution. <p>
<a name="60162"></a>
In this case, if <code>Test</code> had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program.<p>
<a name="46604"></a>
The only requirement on when resolution is performed is that any errors detected during resolution must be thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error. Using the "static" example implementation choice described above, loading and linkage errors could occur before the program is executed if they involved a class or interface mentioned in the class <code>Test</code> or any of the further, recursively referenced, classes and interfaces. In a system &#32;that implemented the "laziest" resolution, these errors would be thrown only when an incorrect symbolic reference is actively used.<p>
<a name="60177"></a>
The resolution process is described further in <a href="execution.doc.html#44524">&#167;12.3.3</a>.<p>
<a name="46634"></a>
<h3>12.1.3    Initialize Test: Execute Initializers</h3>
<a name="46618"></a>
In our continuing example, the virtual machine is still trying to execute the method <code>main</code> of class <code>Test</code>. This is permitted only if the class has been initialized <a href="execution.doc.html#57946">(&#167;12.4.1)</a>.<p>
<a name="46639"></a>
Initialization consists of execution of any class variable initializers and static initializers of the class <code>Test</code>, in textual order. But before <code>Test</code> can be initialized, its direct superclass must be initialized, as well as the direct superclass of its direct superclass, and so on, recursively. In the simplest case, <code>Test</code> has <code>Object</code> as its implicit direct superclass; if class <code>Object</code> has not yet been initialized, then it must be initialized before <code>Test</code> is initialized. Class <code>Object</code> has no superclass, so the recursion terminates here.<p>
<a name="47019"></a>
If class <code>Test</code> has another class <code>Super</code> as its superclass, then <code>Super</code> must be initialized before <code>Test</code>. This requires loading, verifying, and preparing <code>Super</code> if this has not already been done and, depending on the implementation, may also involve resolving the symbolic references from <code>Super</code> and so on, recursively.<p>
<a name="47072"></a>
Initialization may thus cause loading, linking, and initialization errors, including such errors involving other types.<p>
<a name="47023"></a>
The initialization process is described further in <a href="execution.doc.html#44557">&#167;12.4</a>.<p>
<a name="47024"></a>
<h3>12.1.4    Invoke Test.main</h3>
<a name="60153"></a>
Finally, after completion of the initialization for class <code>Test</code> (during which other consequential loading, linking, and initializing may have occurred), the method <code>main</code> of <code>Test</code> is invoked.<p>
<a name="46532"></a>
The method <code>main</code> must be declared <code>public</code>, <code>static</code>, and <code>void</code>. It must accept a single argument that is an array of strings.<p>
<a name="44459"></a>
<h2>12.2    Loading of Classes and Interfaces</h2>
<a name="44460"></a>
<em>Loading</em> refers to the process of finding the binary form of a class or interface type with a particular name, perhaps by computing it on the fly, but more typically by retrieving a binary representation previously computed from source code by a compiler, and constructing, from that binary form, a <code>Class</code> object to represent the class or interface.<p>
<a name="58472"></a>
The precise semantics of loading are given in chapter 5 of <em>The Java</em><i></i><em> Virtual Machine Specification, Second Edition</em>. Here we present an overview of the process from the viewpoint of the Java programming language.<p>
<a name="58481"></a>
The binary format of a class or interface is normally the <code>class</code> file format described in <em>The Java</em><i></i><em> Virtual Machine Specification</em> cited above, but other formats are possible, provided they meet the requirements specified in <a href="binaryComp.doc.html#44909">&#167;13.1</a>. The method <code>defineClass</code> of class <code>ClassLoader</code> may be used to construct <code>Class</code> objects from binary representations in the <code>class</code> file format.<p>
<a name="47927"></a>
Well-behaved class loaders maintain these properties: <p>
<ul><a name="58500"></a>
<li>Given the same name, a good class loader should always return the same class object.
<a name="58501"></a>
<li>If a class loader <i>L1</i> delegates loading of a class <i>C</i> to another loader <i>L2</i>, then for any type <i>T</i> that occurs as the direct superclass or a direct superinterface of <i>C</i>, or as the type of a field in <i>C</i>, or as the type of a formal parameter of a method or constructor in <i>C</i>, or as a return type of a method in <i>C</i>, <i>L1</i> and <i>L2</i> should return the same class object.
</ul><a name="58503"></a>
 A malicious class loader could violate these properties. However, it could not undermine the security of the type system, because the Java virtual machine guards against this. <p>
<a name="74610"></a>
For further discussion of these issues, see <em>The Java</em><i></i><em> Virtual Machine Specification, Second Edition</em> and the paper <em>Dynamic Class Loading in the Java</em><i></i><em> Virtual Machine</em>, by Sheng Liang and Gilad Bracha, in <em>Proceedings of OOPSLA '98</em>, published as <em>ACM SIGPLAN Notices</em>, Volume 33, Number 10, October 1998, pages 36-44. A basic principle of the design of the Java programming language is that the type system cannot be subverted by code written in the language, not even by implementations of such otherwise sensitive system classes as <code>ClassLoader</code> and <code>SecurityManager</code>. <p>
<a name="47907"></a>
<h3>12.2.1    The Loading Process</h3>
<a name="44471"></a>
The loading process is implemented by the class <code>ClassLoader</code> and its subclasses. Different subclasses of <code>ClassLoader</code> may implement different loading policies. In particular, a class loader may cache binary representations of classes and interfaces, prefetch them based on expected usage, or load a group of related classes together. These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because an older version is cached by a class loader. It is the responsibility of a class loader, however, to reflect loading errors only at points in the program they could have arisen without prefetching or group loading. <p>
<a name="44476"></a>
If an error occurs during class loading, then an instance of one of the following subclasses of class <code>LinkageError</code> will be thrown at any point in the program that (directly or indirectly) uses the type:<p>
<ul><a name="44477"></a>
<li><code>ClassCircularityError</code>: A class or interface could not be loaded because it would be its own superclass or superinterface <a href="binaryComp.doc.html#44994">(&#167;13.4.4)</a>.
<a name="44481"></a>
<li><code>ClassFormatError</code>: The binary data that purports to specify a requested compiled class or interface is malformed.
<a name="44482"></a>
<li><code>NoClassDefFoundError</code>: No definition for a requested class or interface could be found by the relevant class loader.
</ul><a name="46207"></a>
Because loading involves the allocation of new data structures, it may fail with an <code>OutOfMemoryError</code>. <p>
<a name="44487"></a>
<h2>12.3    Linking of Classes and Interfaces</h2>
<a name="44488"></a>
<em>Linking</em> is the process of taking a binary form of a class or interface type and combining it into the runtime state of the Java virtual machine, so that it can be executed. A class or interface type is always loaded before it is linked. <p>
<a name="74607"></a>
Three different activities are involved in linking: verification, preparation, and resolution of symbolic references.The precise semantics of linking are given in chapter 5 of <em>The Java</em><i></i><em> Virtual Machine Specification, Second Edition</em>. Here we present an overview of the process from the viewpoint of the Java programming language.<p>
<a name="46466"></a>
This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error.<p>
<a name="46467"></a>
For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.<p>
<a name="46201"></a>
Because linking involves the allocation of new data structures, it may fail with an <code>OutOfMemoryError</code>.<p>
<a name="44491"></a>
<h3>12.3.1    Verification of the Binary Representation</h3>
<a name="44492"></a>
<em>Verification</em> ensures that the binary representation of a class or interface is structurally correct. For example, it checks that every instruction has a valid operation code; that every branch instruction branches to the start of some other instruction, rather than into the middle of an instruction; that every method is provided with a structurally correct signature; and that every instruction obeys the type discipline of the Java virtual machine language. <p>
<a name="44493"></a>
For the specification of the verification process, see the separate volume of this series, <em>The Java</em><i></i><em> Virtual Machine Specification, Second Edition</em>.<p>
<a name="44494"></a>
If an error occurs during verification, then an instance of the following subclass of class <code>LinkageError</code> will be thrown at the point in the program that caused the class to be verified:<p>
<ul><a name="47964"></a>
<li><code>VerifyError</code>: The binary definition for a class or interface failed to pass a set of required checks to verify that it obeys the semantics of the Java virtual machine language and that it cannot violate the integrity of the Java virtual machine. (See <a href="binaryComp.doc.html#44987">&#167;13.4.2</a>, <a href="binaryComp.doc.html#44994">&#167;13.4.4</a>, <a href="binaryComp.doc.html#45139">&#167;13.4.8</a>, and <a href="binaryComp.doc.html#45238">&#167;13.4.15</a> for some examples.)
</ul><a name="47979"></a>
<h3>12.3.2    Preparation of a Class or Interface Type</h3>
<a name="60182"></a>
<em>Preparation</em> involves creating the <code>static</code> fields (class variables and constants) for a class or interface and initializing such fields to the default values <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>. This does not require the execution of any source code; explicit initializers for <code>static</code> fields are executed as part of initialization <a href="execution.doc.html#44557">(&#167;12.4)</a>, not preparation.<p>
<a name="60187"></a>
Implementations of the Java virtual machine may precompute additional data structures at preparation time in order to make later operations on a class or interface more efficient. One particularly useful data structure is a "method table" or other data structure that allows any method to be invoked on instances of a class without requiring a search of superclasses at invocation time.<p>
<a name="44524"></a>
<h3>12.3.3    Resolution of Symbolic References</h3>
<a name="44525"></a>
The binary representation of a class or interface references other classes and interfaces and their fields, methods, and constructors symbolically, using the binary names <a href="binaryComp.doc.html#44909">(&#167;13.1)</a> of the other classes and interfaces <a href="binaryComp.doc.html#44909">(&#167;13.1)</a>. For fields and methods, these symbolic references include the name of the class or interface type that declares the field or method as well as the name of the field or method itself, together with appropriate type information.<p>
<a name="44529"></a>
Before a symbolic reference can be used it must undergo <em>resolution</em>, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly.<p>
<a name="44530"></a>
If an error occurs during resolution, then an error will be thrown. Most typically, this will be an instance of one of the following subclasses of the class <code>IncompatibleClassChangeError</code>, but it may also be an instance of some other subclass of <code>IncompatibleClassChangeError</code> or even an instance of the class <code>IncompatibleClassChangeError</code> itself. This error may be thrown at any point in the program that uses a symbolic reference to the type, directly or indirectly:<p>
<ul><a name="60195"></a>
<li><code>IllegalAccessError</code>: A symbolic reference has been encountered that specifies a use or assignment of a field, or invocation of a method, or creation of an instance of a class, to which the code containing the reference does not have access because the field or method was declared <code>private</code>, <code>protected</code>, or default access (not <code>public</code>), or because the class was not declared <code>public</code>. 
</ul><a name="60201"></a>
This can occur, for example, if a field that is originally declared <code>public</code> is changed to be <code>private</code> after another class that refers to the field has been compiled <a href="binaryComp.doc.html#47259">(&#167;13.4.6)</a>.<p>
<ul><a name="44535"></a>
<li><code>InstantiationError</code>: A symbolic reference has been encountered that is used in class instance creation expression, but an instance cannot be created because the reference turns out to refer to an interface or to an <code>abstract</code> class. 
</ul><a name="60525"></a>
This can occur, for example, if a class that is originally not <code>abstract</code> is changed to be <code>abstract</code> after another class that refers to the class in question has been compiled <a href="binaryComp.doc.html#44980">(&#167;13.4.1)</a>.<p>
<ul><a name="44539"></a>
<li><code>NoSuchFieldError</code>: A symbolic reference has been encountered that refers to a specific field of a specific class or interface, but the class or interface does not contain a field of that name. 
</ul><a name="60526"></a>
This can occur, for example, if a field declaration was deleted from a class after another class that refers to the field was compiled <a href="binaryComp.doc.html#45118">(&#167;13.4.7)</a>.<p>
<ul><a name="44543"></a>
<li><code>NoSuchMethodError</code>: A symbolic reference has been encountered that refers to a specific method of a specific class or interface, but the class or interface does not contain a method of that signature. 
</ul><a name="60527"></a>
This can occur, for example, if a method declaration was deleted from a class after another class that refers to the method was compiled <a href="binaryComp.doc.html#45197">(&#167;13.4.11)</a>.<p>
<a name="49761"></a>
Additionally, an <code>UnsatisfiedLinkError</code> (a subclass of <code>LinkageError</code>) may be thrown if a class declares a <code>native</code> method for which no implementation can be found. The error will occur if the method is used, or earlier, depending on what kind of resolution strategy is being used by the virtual machine <a href="execution.doc.html#44487">(&#167;12.3)</a>.<p>
<a name="44557"></a>
<h2>12.4    Initialization of Classes and Interfaces</h2>
<a name="44558"></a>
Initialization of a class consists of executing its static initializers and the initializers for <code>static</code> fields (class variables) declared in the class. Initialization of an interface consists of executing the initializers for fields (constants) declared there.<p>
<a name="47219"></a>
Before a class is initialized, its superclass must be initialized, but interfaces implemented by the class are not initialized. Similarly, the superinterfaces of an interface are not initialized before the interface is initialized.<p>
<a name="57946"></a>
<h3>12.4.1    When Initialization Occurs</h3>
<a name="57949"></a>
<em>Initialization</em> of a class consists of executing its static initializers and the initializers for static fields declared in the class. <em>Initialization</em> of an interface consists of executing the initializers for fields declared in the interface.<p>
<a name="57866"></a>
Before a class is initialized, its direct superclass must be initialized, but interfaces implemented by the class need not be initialized. Similarly, the superinterfaces of an interface need not be initialized before the interface is initialized. <p>
<a name="57861"></a>
A class or interface type <i>T</i> will be initialized immediately before the first occurrence of any one of the following: <p>
<ul><a name="58040"></a>
<li><i>T </i>is a class and an instance of <i>T</i> is created. 
<a name="58041"></a>
<li><i>T </i>is a class and a static method declared by <i>T</i> is invoked.
<a name="66249"></a>
<li>A static field declared by <i>T</i> is assigned.
<a name="58044"></a>
<li>A static field declared by <i>T</i> is used and the reference to the field is not a compile-time constant <a href="expressions.doc.html#5313">(&#167;15.28)</a>. References to compile-time constants must be resolved at compile time to a copy of the compile-time constant value, so uses of such a field never cause initialization. 
</ul><a name="74432"></a>
Invocation of certain reflective methods in class <code>Class</code> and in package <code>java.lang.reflect</code> also causes class or interface initialization. A class or interface will not be initialized under any other circumstance.<p>
<a name="60212"></a>
The intent here is that a class or interface type has a set of initializers that put it in a consistent state, and that this state is the first state that is observed by other classes. The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope <a href="classes.doc.html#287406">(&#167;8.3.2.3)</a>. This restriction is designed to detect, at compile time, most circular or otherwise malformed initializations. &#32;<p>
<a name="46874"></a>
As shown in an example in <a href="classes.doc.html#287406">&#167;8.3.2.3</a>, the fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable can be observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice. (Such examples can be also constructed for instance variable initialization; see the example at the end of <a href="execution.doc.html#44670">&#167;12.5</a>). The full power of the language is available in these initializers; programmers must exercise some care. This power places an extra burden on code generators, but this burden would arise in any case because the language is concurrent <a href="execution.doc.html#44667">(&#167;12.4.3)</a>.<p>
<a name="44569"></a>
Before a class is initialized, its superclasses are initialized, if they have not previously been initialized.<p>
<a name="44570"></a>
Thus, the test program:<p>
<blockquote><pre>class Super {
	static { System.out.print("Super "); }
}
class One {
	static { System.out.print("One "); }
}
class Two extends Super {
	static { System.out.print("Two "); }
}
class Test {
	public static void main(String[] args) {
		One o = null;
		Two t = new Two();
		System.out.println((Object)o == (Object)t);
	}
}
</pre></blockquote><a name="44587"></a>
prints:<p>
<blockquote><pre>Super Two false
<a name="60216"></a>
The class <code>One</code> is never initialized, because it not used actively and therefore is never linked to. The class <code>Two</code> is initialized only after its superclass <code>Super</code> has been initialized.<p>
</pre></blockquote><a name="44590"></a>
A reference to a class field causes initialization of only the class or interface that actually declares it, even though it might be referred to through the name of a subclass, a subinterface, or a class that implements an interface. <p>
<a name="60226"></a>
The test program:<p>
<blockquote><pre>class Super { static int taxi = 1729; }
class Sub extends Super {
	static { System.out.print("Sub "); }
}
class Test {
	public static void main(String[] args) {
		System.out.println(Sub.taxi);
	}
}
</pre></blockquote><a name="44600"></a>
prints only:<p>
<blockquote><pre>1729
</pre></blockquote><a name="60230"></a>
because the class <code>Sub</code> is never initialized; the reference to <code>Sub.taxi</code> is a reference to a field actually declared in class <code>Super</code> and does not trigger initialization of the class <code>Sub</code>.<p>
<a name="60235"></a>
Initialization of an interface does not, of itself, cause initialization of any of its superinterfaces. <p>
<a name="60239"></a>
Thus, the test program:<p>
<blockquote><pre>interface I {
	int i = 1, ii = Test.out("ii", 2);
}
interface J extends I {
	int j = Test.out("j", 3), jj = Test.out("jj", 4);
}
interface K extends J {
	int k = Test.out("k", 5);
}
class Test {
	public static void main(String[] args) {
		System.out.println(J.i);
		System.out.println(K.j);
	}
	static int out(String s, int i) {
		System.out.println(s + "=" + i);
		return i;
	}
}
</pre></blockquote><a name="44623"></a>
produces the output:<p>
<blockquote><pre>1
j=3
jj=4
3
<a name="60241"></a>
</pre></blockquote>
The reference to <code>J.i</code> is to a field that is a compile-time constant; therefore, it does not cause <code>I</code> to be initialized. The reference to <code>K.j</code> is a reference to a field actually declared in interface <code>J</code> that is not a compile-time constant; this causes initialization of the fields of interface <code>J</code>, but not those of its superinterface <code>I</code>, nor those of interface <code>K</code>. Despite the fact that the name <code>K</code> is used to refer to field <code>j</code> of interface <code>J</code>, interface <code>K</code> is not initialized.<p>
<a name="44630"></a>
<h3>12.4.2    Detailed Initialization Procedure</h3>
<a name="44631"></a>
Because the Java programming language is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time. There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface; for example, a variable initializer in class <i>A</i> might invoke a method of an unrelated class <i>B</i>, which might in turn invoke a method of class <i>A</i>. The implementation of the Java virtual machine is responsible for taking care of synchronization and recursive initialization by using the following procedure. It assumes that the <code>Class</code> object has already been verified and prepared, and that the <code>Class</code> object contains state that indicates one of four situations:<p>
<ul><a name="44632"></a>
<li>This <code>Class</code> object is verified and prepared but not initialized.
<a name="44633"></a>
<li>This <code>Class</code> object is being initialized by some particular thread <i>T</i>.
<a name="44634"></a>
<li>This <code>Class</code> object is fully initialized and ready for use.
<a name="44635"></a>
<li>This <code>Class</code> object is in an erroneous state, perhaps because the verification or preparation step failed, or because initialization was attempted and failed.
</ul><a name="44636"></a>
The procedure for initializing a class or interface is then as follows:<p>
<ol>
<a name="44640"></a>
<li>Synchronize <a href="statements.doc.html#255769">(&#167;14.18)</a> on the <code>Class</code> object that represents the class or interface to be initialized. This involves waiting until the current thread can obtain the lock for that object <a href="memory.doc.html#28460">(&#167;17.13)</a>.
<a name="44644"></a>
<li>If initialization is in progress for the class or interface by some other thread, then <code>wait</code> on this <code>Class</code> object (which temporarily releases the lock). When the current thread awakens from the <code>wait</code>, repeat this step.
<a name="44648"></a>
<li>If initialization is in progress for the class or interface by the current thread, then this must be a recursive request for initialization. Release the lock on the <code>Class</code> object and complete normally.
<a name="44649"></a>
<li>If the class or interface has already been initialized, then no further action is required. Release the lock on the <code>Class</code> object and complete normally.
<a name="44650"></a>
<li>If the <code>Class</code> object is in an erroneous state, then initialization is not possible. Release the lock on the <code>Class</code> object and throw a <code>NoClassDefFoundError</code>.
<a name="44651"></a>
<li>Otherwise, record the fact that initialization of the <code>Class</code> object is now in progress by the current thread and release the lock on the <code>Class</code> object.
<a name="44652"></a>
<li>Next, if the <code>Class</code> object represents a class rather than an interface, and the superclass of this class has not yet been initialized, then recursively perform this entire procedure for the superclass. If necessary, verify and prepare the superclass first. If the initialization of the superclass completes abruptly because of a thrown exception, then lock this <code>Class</code> object, label it erroneous, notify all waiting threads, release the lock, and complete abruptly, throwing the same exception that resulted from initializing the superclass.
<a name="44656"></a>
<li>Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block, except that <code>final</code> class variables and fields of interfaces whose values are compile-time constants are initialized first (<a href="classes.doc.html#38010">&#167;8.3.2.1</a>, <a href="interfaces.doc.html#40720">&#167;9.3.1</a>, <a href="binaryComp.doc.html#45139">&#167;13.4.8</a>).
<a name="44657"></a>
<li>If the execution of the initializers completes normally, then lock this <code>Class</code> object, &#32;label it fully initialized, notify all waiting threads, release the lock, and complete this procedure normally.
<a name="44661"></a>
<li>Otherwise, the initializers must have completed abruptly by throwing some exception &#32;<i>E</i>. If the class of <i>E</i> is not <code>Error</code> or one of its subclasses, then create a new instance of the class <code>ExceptionInInitializerError</code>, with <i>E</i> as the argument, and use this object in place of <i>E</i> in the following step. But if a new instance of <code>ExceptionInInitializerError</code> cannot be created because an <code>OutOfMemoryError</code> occurs, then instead use an <code>OutOfMemoryError</code> object in place of <i>E</i> in the following step.
<a name="60250"></a>
<li>Lock the <code>Class</code> object, label it erroneous, notify all waiting threads, release the lock, and complete this procedure abruptly with reason <i>E</i> or its replacement as determined in the previous step.
<a name="60264"></a>
(Due to a flaw in some early implementations, a exception during class initialization was ignored, rather than causing an <code>ExceptionInInitializerError</code> as described here.) <p>
</ol>
<a name="44667"></a>
<h3>12.4.3    Initialization: Implications for Code Generation</h3>
<a name="44668"></a>
Code generators need to preserve the points of possible initialization of a class or interface, inserting an invocation of the initialization procedure just described. If this initialization procedure completes normally and the <code>Class</code> object is fully initialized and ready for use, then the invocation of the initialization procedure is no longer necessary and it may be eliminated from the code-for example, by patching it out or otherwise regenerating the code.<p>
<a name="46847"></a>
Compile-time analysis may, in some cases, be able to eliminate many of the checks that a type has been initialized from the generated code, if an initialization order for a group of related types can be determined. Such analysis must, however, fully account for concurrency and for the fact that initialization code is unrestricted.<p>
<a name="44670"></a>
<h2>12.5    Creation of New Class Instances</h2>
<a name="44671"></a>
A new class instance is explicitly created when evaluation of a class instance creation expression <a href="expressions.doc.html#41147">(&#167;15.9)</a> causes a class to be instantiated.<p>
<a name="44680"></a>
A new class instance may be implicitly created in the following situations:<p>
<ul><a name="44684"></a>
<li>Loading of a class or interface that contains a <code>String</code> literal <a href="lexical.doc.html#101083">(&#167;3.10.5)</a> may create a new <code>String</code> object to represent that literal. (This might not occur if the same <code>String</code> has previously been interned <a href="lexical.doc.html#101083">(&#167;3.10.5)</a>.)
<a name="44691"></a>
<li>Execution of a string concatenation operator <a href="expressions.doc.html#39990">(&#167;15.18.1)</a> that is not part of a constant expression sometimes creates a new <code>String</code> object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type.
</ul><a name="44692"></a>
Each of these situations identifies a particular constructor to be called with specified arguments (possibly none) as part of the class instance creation process.<p>
<a name="44693"></a>
Whenever a new class instance is created, memory space is allocated for it with room for all the instance variables declared in the class type and all the instance variables declared in each superclass of the class type, including all the instance variables that may be hidden <a href="classes.doc.html#40898">(&#167;8.3)</a>. If there is not sufficient space available to allocate memory for the object, then creation of the class instance completes abruptly with an <code>OutOfMemoryError</code>. Otherwise, all the instance variables in the new object, including those declared in superclasses, are initialized to their default values <a href="typesValues.doc.html#96595">(&#167;4.5.5)</a>. <p>
<a name="74612"></a>
Just before a reference to the newly created object is returned as the result, the indicated constructor is processed to initialize the new object using the following procedure:<p>
<ol>
<a name="58547"></a>
<li>Assign the arguments for the constructor to newly created parameter variables for this constructor invocation.
<a name="58549"></a>
<li>If this constructor begins with an explicit constructor invocation of another constructor in the same class (using <code>this</code>), then evaluate the arguments and process that constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason; otherwise, continue with step 5.
<a name="44699"></a>
<li>This constructor does not begin with an explicit constructor invocation of another constructor in the same class (using <code>this</code>). If this constructor is for a class other than <code>Object</code>, then this constructor will begin with an explicit or implicit invocation of a superclass constructor (using <code>super</code>). Evaluate the arguments and process that superclass constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, continue with step 4.
<a name="44700"></a>
<li>Execute the instance initializers and instance variable initializers for this class, assigning the values of instance variable initializers to the corresponding instance variables, in the left-to-right order in which they appear textually in the source code for the class. If execution of any of these initializers results in an exception, then no further initializers are processed and this procedure completes abruptly with that same exception. Otherwise, continue with step 5. (In some early implementations, the compiler incorrectly omitted the code to initialize a field if the field initializer expression was a constant expression whose value was equal to the default initialization value for its type.)
<a name="44701"></a>
<li>Execute the rest of the body of this constructor. If that execution completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, this procedure completes normally.
<a name="60273"></a>
In the example:<p>
</ol>
<blockquote><pre>class Point {
	int x, y;
	Point() { x = 1; y = 1; }
}
class ColoredPoint extends Point {
	int color = 0xFF00FF;
}
class Test {
	public static void main(String[] args) {
		ColoredPoint cp = new ColoredPoint();
		System.out.println(cp.color);
	}
}
</pre></blockquote><a name="44716"></a>
a new instance of <code>ColoredPoint</code> is created. First, space is allocated for the new <code>ColoredPoint</code>, to hold the fields <code>x</code>, <code>y</code>, and <code>color</code>. All these fields are then initialized to their default values (in this case, <code>0</code> for each field). Next, the <code>ColoredPoint</code> constructor with no arguments is first invoked. Since <code>ColoredPoint</code> declares no constructors, a default constructor of the form:<p>
<blockquote><pre>ColoredPoint() { super(); }
</pre></blockquote><a name="44718"></a>
is provided for it automatically by the Java compiler.<p>
<a name="44719"></a>
This constructor then invokes the <code>Point</code> constructor with no arguments. The <code>Point</code> constructor does not begin with an invocation of a constructor, so the compiler provides an implicit invocation of its superclass constructor of no arguments, as though it had been written:<p>
<blockquote><pre>Point() { super(); x = 1; y = 1; }
</pre></blockquote><a name="44721"></a>
Therefore, the constructor for <code>Object</code> which takes no arguments is invoked.<p>
<a name="46262"></a>
The class <code>Object</code> has no superclass, so the recursion terminates here. Next, any instance initializers, instance variable initializers of <code>Object</code> are invoked. Next, the body of the constructor of <code>Object</code> that takes no arguments is executed. No such constructor is declared in <code>Object</code>, so the compiler supplies a default one, which in this special case is:<p>
<blockquote><pre>Object() { }
</pre></blockquote><a name="44723"></a>
This constructor executes without effect and returns.<p>
<a name="44724"></a>
Next, all initializers for the instance variables of class <code>Point</code> are executed. As it happens, the declarations of <code>x</code> and <code>y</code> do not provide any initialization expressions, so no action is required for this step of the example. Then the body of the <code>Point</code> constructor is executed, setting <code>x</code> to <code>1</code> and <code>y</code> to <code>1</code>.<p>
<a name="44725"></a>
Next, the initializers for the instance variables of class <code>ColoredPoint</code> are executed. This step assigns the value <code>0xFF00FF</code> to <code>color</code>. Finally, the rest of the body of the <code>ColoredPoint</code> constructor is executed (the part after the invocation of <code>super</code>); there happen to be no statements in the rest of the body, so no further action is required and initialization is complete.<p>
<a name="44726"></a>
Unlike C++, the Java programming language does not specify altered rules for method dispatch during the creation of a new class instance. If methods are invoked that are overridden in subclasses in the object being initialized, then these overriding methods are used, even before the new object is completely initialized. Thus, compiling and running the example:<p>
<blockquote><pre>class Super {
	Super() { printThree(); }
	void printThree() { System.out.println("three"); }
}
<a name="48340"></a>
<p>
<a name="48341"></a>
<p>
class Test extends Super {
	int three = (int)Math.PI;													// That is, 3
	public static void main(String[] args) {
		Test t = new Test();
		t.printThree();
	}
	void printThree() { System.out.println(three); }
}
</pre></blockquote><a name="44739"></a>
produces the output:<p>
<blockquote><pre><code>0
</code>3
</pre></blockquote><a name="44742"></a>
This shows that the invocation of <code>printThree</code> in the constructor for class <code>Super</code> does not invoke the definition of <code>printThree</code> in class <code>Super</code>, but rather invokes the overriding definition of <code>printThree</code> in class <code>Test</code>. This method therefore runs before the field initializers of <code>Test</code> have been executed, which is why the first value output is <code>0</code>, the default value to which the field <code>three</code> of <code>Test</code> is initialized. The later invocation of <code>printThree</code> in method <code>main</code> invokes the same definition of <code>printThree</code>, but by that point the initializer for instance variable <code>three</code> has been executed, and so the value <code>3</code> is printed.<p>
<a name="60275"></a>
See <a href="classes.doc.html#41652">&#167;8.8</a> for more details on constructor declarations.<p>
<a name="44748"></a>
<h2>12.6    Finalization of Class Instances</h2>
<a name="60280"></a>
The class <code>Object</code> has a <code>protected</code> method called <code>finalize</code>; this method can be overridden by other classes. The particular definition of <code>finalize</code> that can be invoked for an object is called the <em>finalizer</em> of that object. Before the storage for an object is reclaimed by the garbage collector, the Java virtual machine will invoke the finalizer<em> </em>of that object.<p>
<a name="60285"></a>
Finalizers provide a chance to free up resources that cannot be freed automatically by an automatic storage manager. In such situations, simply reclaiming the memory used by an object would not guarantee that the resources it held would be reclaimed.<p>
<a name="44754"></a>
The Java programming language does not specify how soon a finalizer will be invoked, except to say that it will happen before the storage for the object is reused. Also, the language does not specify which thread will invoke the finalizer for any given object. It is guaranteed, however, that the thread that invokes the finalizer will not be holding any user-visible synchronization locks when the finalizer is invoked. If an uncaught exception is thrown during the finalization, the exception is ignored and finalization of that object terminates.<p>
<a name="44755"></a>
The <code>finalize</code> method declared in class <code>Object</code> takes no action. <p>
<a name="60295"></a>
The fact that class <code>Object</code> declares a <code>finalize</code> method means that the <code>finalize</code> method for any class can always invoke the <code>finalize</code> method for its superclass, which is usually good practice. (Unlike constructors, finalizers do not automatically invoke the finalizer for the superclass; such an invocation must be coded explicitly.)<p>
<a name="44756"></a>
For efficiency, an implementation may keep track of classes that do not override the <code>finalize</code> method of class <code>Object</code>, or override it in a trivial way, such as:<p>
<blockquote><pre>protected void finalize() throws Throwable {
	super.finalize();
}
<a name="60299"></a>
We encourage implementations to treat such objects as having a finalizer that is not overridden, and to finalize them more efficiently, as described in <a href="execution.doc.html#44760">&#167;12.6.1</a>.<p>
</pre></blockquote><a name="44759"></a>
A finalizer may be invoked explicitly, just like any other method.<p>
<a name="72893"></a>
The package <code>java.lang.ref</code> describes weak references, which interact with garbage collection and finalization. As with any API that has special interactions with the language, implementors must be cognizant of any requirements imposed by the <code>java.lang.ref</code> API. This specification does not discuss weak references in any way. Readers are referred to the API documentation for details.<p>
<a name="44760"></a>
<h3>12.6.1    Implementing Finalization</h3>
<a name="44761"></a>
Every object can be characterized by two attributes: it may be <em>reachable</em>, <em>finalizer-reachable</em>, or <em>unreachable</em>, and it may also be <em>unfinalized</em>, <em>finalizable</em>, or <em>finalized</em>.<p>
<a name="44762"></a>
A <em>reachable</em> object is any object that can be accessed in any potential continuing computation from any live thread. Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable. For example, a compiler or code generator may choose to set a variable or parameter that will no longer be used to <code>null</code> to cause the storage for such an object to be potentially reclaimable sooner. A <em>finalizer-reachable</em> object can be reached from some finalizable object through some chain of references, but not from any live thread. An <em>unreachable</em> object cannot be reached by either means.<p>
<a name="74691"></a>
An <em>unfinalized</em> object has never had its finalizer automatically invoked; a <em>finalized</em> object has had its finalizer automatically invoked. A <em>finalizable</em> object has never had its finalizer automatically invoked, but the Java virtual machine may eventually automatically invoke its finalizer.<p>
<a name="74701"></a>
The life cycle of an object obeys the following transition diagram, where we abbreviate "finalizer-reachable" as "f-reachable":<br>
<img src="execution.doc.anc.gif"><p>
<a name="48818"></a>
When an object is first created (A), it is reachable and unfinalized.<p>
<a name="48565"></a>
As references to an object are discarded during program execution, an object that was reachable may become finalizer-reachable (B, C, D) or unreachable (E, F). (Note that a finalizer-reachable object never becomes unreachable directly; it becomes reachable when the finalizer from which it can be reached is invoked, as explained below.)<p>
<a name="44823"></a>
If the Java virtual machine detects that an unfinalized object has become finalizer-reachable or unreachable, it may label the object finalizable (G, H); moreover, if the object was unreachable, it becomes finalizer-reachable (H).<p>
<a name="44824"></a>
If the Java virtual machine detects that a finalized object has become unreachable, it may reclaim the storage occupied by the object because the object will never again become reachable (I).<p>
<a name="44825"></a>
At any time, a Java virtual machine may take any finalizable object, label it finalized, and then invoke its <code>finalize</code> method in some thread. This causes the object to become finalized and reachable (J, K), and it also may cause other objects that were finalizer-reachable to become reachable again (L, M, N).<p>
<a name="60314"></a>
A finalizable object cannot also be unreachable; it can be reached because its finalizer may eventually be invoked, whereupon the thread running the finalizer will have access to the object, as <code>this</code> <a href="expressions.doc.html#251519">(&#167;15.8.3)</a>. Thus, there are actually only eight possible states for an object.<p>
<a name="44830"></a>
After an object has been finalized, no further action is taken until the automatic storage management determines that it is unreachable. Because of the way that an object progresses from the <em>unfinalized</em> state through the <em>finalizable</em> state to the <em>finalized</em> state, the <code>finalize</code> method is never automatically invoked more than once by a Java virtual machine for each object, even if the object is again made reachable after it has been finalized.<p>
<a name="44831"></a>
Explicit invocation of a finalizer ignores the current state of the object and does not change the state of the object from unfinalized or finalizable to finalized.<p>
<a name="44832"></a>
If a class does not override method <code>finalize</code> of class <code>Object</code> (or overrides it in only a trivial way, as described above), then if instances of such a class become unreachable, they may be discarded immediately rather than made to await a second determination that they have become unreachable. This strategy is indicated by the dashed arrow (O) in the transition diagram.<p>
<a name="60325"></a>
Therefore, we recommend that the design of <code>finalize</code> methods be kept simple and that they be programmed defensively, so that they will work in all cases.<p>
<a name="44837"></a>
<h3>12.6.2    Finalizer Invocations are Not Ordered</h3>
<a name="44838"></a>
The Java programming language imposes no ordering on finalize method calls. Finalizers may be called in any order, or even concurrently.<p>
<a name="60334"></a>
As an example, if a circularly linked group of unfinalized objects becomes unreachable (or finalizer-reachable), then all the objects may become finalizable together. Eventually, the finalizers for these objects may be invoked, in any order, or even concurrently using multiple threads. If the automatic storage manager later finds that the objects are unreachable, then their storage can be reclaimed.<p>
<a name="60338"></a>
It is straightforward to implement a class that will cause a set of finalizer-like methods to be invoked in a specified order for a set of objects when all the objects become unreachable. Defining such a class is left as an exercise for the reader.<p>
<a name="74294"></a>
<h2>12.7    Unloading of Classes and Interfaces</h2>
<a name="74299"></a>
An implementation of the Java programming language may <em>unload</em> classes. A class or interface may be unloaded if and only if its defining class loader may be reclaimed by the garbage collector as discussed in <a href="execution.doc.html#44748">&#167;12.6</a>. Classes and interfaces loaded by the bootstrap loader may not be unloaded.<p>
<a name="72655"></a>
Here is the rationale for the rule given in the previous paragraph:<p>
<a name="72922"></a>
Class unloading is an optimization that helps reduce memory use. Obviously, the semantics of a program should not depend on whether and how a system chooses to implement an optimization such as class unloading. To do otherwise would compromise the portability of programs. Consequently, whether a class or interface has been unloaded or not should be transparent to a program.<p>
<a name="72656"></a>
However, if a class or interface <i>C</i> was unloaded while its defining loader was potentially reachable, then <i>C</i> might be reloaded. One could never ensure that this would not happen. Even if the class was not referenced by any other currently loaded class, it might be referenced by some class or interface, <i>D</i>, that had not yet been loaded. When <i>D</i> is loaded by <i>C</i>'s defining loader, its execution might cause reloading of <i>C</i>.<p>
<a name="72657"></a>
Reloading may not be transparent if, for example, the class has: <p>
<ul><a name="72658"></a>
<li>Static variables (whose state would be lost). 
<a name="72659"></a>
<li>Static initializers (which may have side effects). 
<a name="72660"></a>
<li>Native methods (which may retain static state). 
</ul>
<a name="72662"></a>
Furthermore the hash value of the <code>Class</code> object is dependent on its identity. Therefore it is, in general, impossible to reload a class or interface in a completely transparent manner. <p>
<a name="72663"></a>
Since we can never guarantee that unloading a class or interface whose loader is potentially reachable will not cause reloading, and reloading is never transparent, but unloading must be transparent, it follows that one must not unload a class or interface while its loader is potentially reachable. A similar line of reasoning can be used to deduce that classes and interfaces loaded by the bootstrap loader can never be unloaded.<p>
<a name="72906"></a>
One must also argue why it is safe to unload a class <i>C</i> if its defining class loader can be reclaimed. If the defining loader can be reclaimed, then there can never be any live references to it (this includes references that are not live, but might be resurrected by finalizers). This, in turn, can only be true if there are can never be any live references to any of the classes defined by that loader, including <i>C</i>, either from their instances or from code.<p>
<a name="72813"></a>
Class unloading is an optimization that is only significant for applications that load large numbers of classes and that stop using most of those classes after some time. A prime example of such an application is a web browser, but there are others. A characteristic of such applications is that they manage classes through explicit use of class loaders. As a result, the policy outlined above works well for them.<p>
<a name="72668"></a>
Strictly speaking, it is not essential that the issue of class unloading be discussed by this specification, as class unloading is merely an optimization. However, the issue is very subtle, and so it is mentioned here by way of clarification. <p>
<a name="44857"></a>
<h2>12.8    Program Exit</h2>
<a name="44858"></a>
A program terminates all its activity and <em>exits</em> when one of two things happens:<p>
<ul><a name="44862"></a>
<li>All the threads that are not daemon threads terminate.
<a name="44866"></a>
<li>Some thread invokes the <code>exit</code> method of class <code>Runtime</code> or class <code>System</code> and the exit operation is not forbidden by the security manager.
</ul><a name="44870"></a>
<p>


<hr>
<table border="0" width="100%">
<tr>
<td><a href="jTOC.doc.html">Contents</a> | <a href="exceptions.doc.html">Prev</a> | <a href="binaryComp.doc.html">Next</a> | <a href="jIX.fm.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Second Edition</font></td></tr></table>
<i><a href="jcopyright.doc.html">Copyright</a> &#169 2000 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jls@java.sun.com">jls@java.sun.com</a>
</font>
</body></html>
